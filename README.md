# What happens when you compile and run this program on macOS?

I spend too much time in Python land and always have to re-learn compiler/linker/loader/etc. terminology and workflows. These are (probably incorrect at times!) notes on the subject as well as a reference for macOS-specific tool usage I always have to look up.

Build the project with:
```shell
$ make
```

## The compiler translates the C code into assembly code

The preprocessed C file can now be translated into a assembly file. This step covers everything from "straightforward" C -> assembly conversation (e.g. C's `printf` to assembly's `callq _printf`) but also the more complex optimizations that you may read about in a book on compilers.

### How do I see the assembly of my C code?

```shell
$ gcc -S say.c # writes say.s to the filesystem
```

## The assembler converts assembly code to machine code (object files)

The ASCII text assembly code generated by the compiler is then converted to a more compact and machine readable binary representation of the assembly (i.e. 'machine code').

Although the object file outputs are machine code, they are not yet executable. It isn't until both object files are combined by the linker that they form an executable.

Object files also contain a symbol table, which is a list of defined and needed symbols and, if available, their assembler-assigned addresses within the object file. These addresses are not exactly what will be used in the final executable, as the linker needs to combine all object files in such a way where each object's temporary address space works for the entire executable.

### How do I produce an object file?

```shell
$ gcc -c foo.c # will create foo.o
$ gcc -c foo.s # will create foo.o if you only have assembly
```

### How can I find where a symbol is defined?

```shell
$ lldb hello
(lldb) image lookup -r -s say_hello
2 symbols match the regular expression 'say_hello' in $PWD/hello:
        Address: hello[0x0000000100000f70] (hello.__TEXT.__text + 80)
        Summary: hello`dont_say_hello        Address: hello[0x0000000100000f40] (hello.__TEXT.__text + 32)
```

### How do I see the symbol table of an object file?

From the command line:

```shell
$ xcrun nm -nm say.o
                 (undefined) external _printf
0000000000000000 (__TEXT,__text) external _say_hello
0000000000000030 (__TEXT,__text) external _dont_say_hello
$ xcrun nm -nm main.o
                 (undefined) external _dont_say_hello
                 (undefined) external _say_hello
0000000000000000 (__TEXT,__text) external _main
0000000000000030 (__DATA,__data) external _UNIVERSE
0000000000000038 (__DATA,__data) non-external _WORLD
```

A few notes on this output:

* Symbols marked "undefined" are used in a given object file but don't have known locations. The linker is expected to resolve this.

* The `static` `WORLD` constant is labeled `non-external` which means it is private to the object file.

* Output like `(__TEXT,__text) ` is defined as `(segment_name, section_name)`. Different segments contains different types of data (e.g. executable code, read-only data, etc.).

### How do I view the disassmbly of an object file?

From the command line:

```shell
$ otool -tvV main.o say.o
main.o:
(__TEXT,__text) section
_main:
0000000000000000    pushq   %rbp
0000000000000001    movq    %rsp, %rbp
0000000000000004    movq    _WORLD(%rip), %rdi
000000000000000b    callq   _say_hello
0000000000000010    movq    _UNIVERSE(%rip), %rdi
0000000000000017    callq   _dont_say_hello
000000000000001c    xorl    %eax, %eax
000000000000001e    popq    %rbp
000000000000001f    retq
say.o:
(__TEXT,__text) section
_say_hello:
0000000000000000    pushq   %rbp
0000000000000001    movq    %rsp, %rbp
0000000000000004    subq    $0x10, %rsp
0000000000000008    leaq    0x2b(%rip), %rax ## literal pool for: "Hello, %s!\n"
000000000000000f    movq    %rdi, -0x8(%rbp)
0000000000000013    movq    -0x8(%rbp), %rsi
0000000000000017    movq    %rax, %rdi
000000000000001a    movb    $0x0, %al
000000000000001c    callq   _printf
0000000000000021    movl    %eax, -0xc(%rbp)
0000000000000024    addq    $0x10, %rsp
0000000000000028    popq    %rbp
0000000000000029    retq
000000000000002a    nopw    (%rax,%rax)
_dont_say_hello:
0000000000000030    pushq   %rbp
0000000000000031    movq    %rsp, %rbp
0000000000000034    movq    %rdi, -0x8(%rbp)
0000000000000038    popq    %rbp
0000000000000039    retq
```

## The linker combines objects into a ready-to-execute binary 

The linker then takes the provided objects and gives instructions final memory locations across the entire executable as well as resolves all unresolved symbols.

The latter involves both resolving symbols across statically built symbols across object files and inserting the appropriate Mach-O directives stating what dynamic library resolves that symbol. You can see this by looking at the symbol table for the final executable:

```shell
$ nm -nm hello
                 (undefined) external _printf (from libSystem)
                 (undefined) external dyld_stub_binder (from libSystem)
0000000100000000 (__TEXT,__text) [referenced dynamically] external __mh_execute_header
0000000100000f20 (__TEXT,__text) external _main
0000000100000f40 (__TEXT,__text) external _say_hello
0000000100000f70 (__TEXT,__text) external _dont_say_hello
0000000100001018 (__DATA,__data) external _UNIVERSE
0000000100001020 (__DATA,__data) non-external _WORLD
```


### What is the difference between `.o` files and `.so` files?

`.o` files are object files that are linked into the executable at build-time (i.e. statically linked).

`.so` (or `.dylib` files on macOS) files are object files that are not linked into the executable but tied to execution (i.e. dynamically linked).

["Mach-O Programming Topics"](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001827-SW1) has a ton of great content on different Mach-O formats.

### How do I know if a file is a bundle or an object file or an shared library?

otool's `filetype` column in its Mach-O header output should specify:

```shell
$ otool -hv say.o
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL  0x00      OBJECT     4        520 SUBSECTIONS_VIA_SYMBOLS
$ otool -hv /usr/lib/libSystem.B.dylib
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL  0x00       DYLIB    48       3656   NOUNDEFS DYLDLINK TWOLEVEL APP_EXTENSION_SAFE
$ otool -hv /usr/lib/zsh/5.3/zsh/regex.so
Mach header
      magic cputype cpusubtype  caps    filetype ncmds sizeofcmds      flags
MH_MAGIC_64  X86_64        ALL  0x00      BUNDLE    15       1376 DYLDLINK
```

### How do I know what dynamic libaries are used by an object file or executable?

otool can do this (sorta):

```shell
$ otool -L hello
hello:
        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1252.200.5)
```

That is useful, but it doesn't work recursively (That is, libSystem **also* has
libaries it dynamically links to) like the Linux utility `ldd`.  In order to
iterate on this, we can use [bash hackery](https://gist.github.com/drkibitz/8896013).

Alternatively, if you can just run the binary, you can use `DYLD_**\*` environment variables:

```shell
$ DYLD_PRINT_LIBRARIES=1 ./hello
dyld: loaded: $PATH/./hello
dyld: loaded: /usr/lib/libSystem.B.dylib
dyld: loaded: /usr/lib/system/libcache.dylib
dyld: loaded: /usr/lib/system/libcommonCrypto.dylib
dyld: loaded: /usr/lib/system/libcompiler_rt.dylib
<snip>
dyld: loaded: /usr/lib/libc++.1.dylib
Hello, World!
$ # see `man dyld` for more!
```

### How do I see my linker search paths?

```shell
$ clang -Xlinker -v
<snip>
configured to support archs: armv6 armv7 armv7s arm64 i386 x86_64 x86_64h armv6m armv7k armv7m armv7em
Library search paths:
        /usr/local/lib
        /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/usr/lib
Framework search paths:
        /Library/Developer/CommandLineTools/SDKs/MacOSX10.14.sdk/System/Library/Frameworks/
<snip>
```

## The loader loads the executable into memory and begins execution

The loader is responsible for:

* Parsing Mach-O directives

* Loading relevant instructions/data from the executable into memory

* Resolving dynamic symbols

# Misc. Questions and Answers

## How do I view debug symbol information?

```shell
$ dsymutil -s hello # compare to hello-debug!
----------------------------------------------------------------------
Symbol table for: 'hello' (x86\_64)
----------------------------------------------------------------------
Index    n\_strx   n\_type             n\_sect n\_desc n\_value
======== -------- ------------------ ------ ------ ----------------
[     0] 0000005a 0e (     SECT    ) 08     0000   0000000100001020 '_WORLD'
[     1] 00000002 0f (     SECT EXT) 08     0000   0000000100001018 '_UNIVERSE'
[     2] 0000000c 0f (     SECT EXT) 01     0010   0000000100000000 '__mh_execute_header'
[     3] 00000020 0f (     SECT EXT) 01     0000   0000000100000f70 '_dont_say_hello'
[     4] 00000030 0f (     SECT EXT) 01     0000   0000000100000f20 '_main'
<snip>
```

# References

* [Object Files and Symbols](https://nickdesaulniers.github.io/blog/2016/08/13/object-files-and-symbols/)

* [obc.io - The Compiler](https://www.objc.io/issues/6-build-tools/compiler/)

* [obc.io - Mach-O Executables](https://www.objc.io/issues/6-build-tools/mach-o-executables/)

* [Compilers, Assemblers, Linkers, Loaders: A Short Course](https://courses.cs.washington.edu/courses/cse378/97au/help/compilation.html)

* [Mach-O Programming Topics](https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/0-Introduction/introduction.html#//apple_ref/doc/uid/TP40001827-SW1)
